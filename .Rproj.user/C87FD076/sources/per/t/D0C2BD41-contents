#' Function for estimating a random parameter negative binomial with the ability to specify if the NB-1, NB-2, or NB-P should be used
#'
#' @name rpnb
#' @param formula an R formula.. This formula should specify the outcome and the independent variables that have fixed parameters.
#' @param rpar_formula a symbolic description of the model related specifically to the random parameters. This should not include an outcome variable. If the intercept is random, include it in this formula. If the intercept is fixed, include it in \code{formula} but not in \code{rpar_formula}. To remove the intercept, use \code{0 + vars} or \code{-1 + vars},
#' @param data a dataframe that has all of the variables in the \code{formula} and \code{rpar_formula},
#' @param form the version of the negative binomial to estimate (\code{"nb2"} estimates the NB-2, \code{"nb1"} estimates the NB-1, \code{"nbp"} estimates the NB-P). For further details see \code{\link{nbg}}.
#' @param rpardists an optional named vector whose names are the random parameters and values the distribution. The distribution options include normal ("n"), lognormal ("ln"), triangular ("t"), uniform ("u"), and gamma ("g"). If this is not provided, normal distributions are used for all random coefficients,
#' @param ndraws the number of Halton draws to use for estimating the random parameters,
#' @param scrambled if the Halton draws should be scrambled or not. \code{scrambled = FALSE} results in standard Halton draws while \code{scrambled = FALSE} results in scrambled Halton draws,
#' @param correlated if the random parameters should be correlated (\code{correlated = FALSE} results in uncorrelated random coefficients, \code{correlated = TRUE} results in correlated random coefficients). If the random parameters are correlated, only the normal distribution is used for the random coefficients,
#' @param method a method to use for optimization in the maximum likelihood estimation. For options, see \code{\link[maxLik]{maxLik}},
#' @param max.iters the maximum number of iterations to allow the optimization method to perform,
#' @param start.vals an optional vector of starting values for the regression coefficients
#' @param print.level determines the level of verbosity for printing details of the optimization as it is computed. A value of 0 does not print out any information, a value of 1 prints minimal information, and a value of 2 prints the most information.
#' @import MASS nlme randtoolbox maxLik stats modelr
#' @importFrom utils head  tail
#' @include tri.R
#'
#' @examples
#' \donttest{
#' ## Random Parameters Negative Binomial model (NB-2)
#' data("washington_roads")
#' nb2.rp <- rpnb(Total_crashes ~ - 1 + lnlength + lnaadt,
#'                rpar_formula = ~ speed50,
#'                data = washington_roads,
#'                ndraws = 100,
#'                correlated = TRUE,
#'                form = 'nb2',
#'                method = "nr",
#'                print.level = 1)
#'
#' summary(nb2.rp)}
#' @export
rpnb <- function(formula, rpar_formula, data, form = 'nb2',
                 rpardists = NULL,
                 ndraws = 1500, scrambled = FALSE,
                 correlated = FALSE, method = 'BHHH', max.iters = 1000,
                 start.vals = NULL, print.level = 0) {
  # start.vals can be a vector or a named vector with the starting values for the parameters
  # print.level is used to determine the level of details for the optimization to print (for the maxLik function call)
  
  sd.start <- 0.1 # starting value for each of the standard deviations of random parameters
  
  # Check and correct the rpardists if the random parameters are correlated
  if(correlated && !is.null(rpardists)){
    print("When the random parameters are correlated, only the normal distribution is used.")
    rpardists <- NULL
  }
  
  # Function to generate Halton draws
  halton_draws <- function(ndraws, rpar, scrambled) {
    num_params <- length(rpar)
    halton_seq <- randtoolbox::halton(ndraws, num_params, mixed = scrambled)
    return(halton_seq)
  }
  
  # function to compute probabilities
  nb_prob <- function(y, mu, alpha, p) {
    if (form=='nb2'){
      return(stats::dnbinom(y, size = alpha, mu = mu))
    } else if (form=='nb1'){
      return(stats::dnbinom(y, size = mu/alpha, mu = mu))
    } else{
      return(stats::dnbinom(y, size = (mu^(2-p))/alpha, mu = mu))
    }
  }
  
  # Generating model matrices
  mod1_frame <- stats::model.frame(formula, data)
  X_Fixed <- modelr::model_matrix(data, formula)
  X_rand <- modelr::model_matrix(data, rpar_formula)
  #X_rand <-stats::model.matrix(rpar_formula, data)
  y_name <- all.vars(formula)[1]
  y <- stats::model.response(mod1_frame)
  
  X_expanded <- cbind(X_Fixed, X_rand, X_rand) # for use in the gradient
  
  # Create named vectors
  fixed_terms <- names(X_Fixed)
  rand_terms <- names(X_rand)
  predictor_terms <- c(fixed_terms, rand_terms)
  nb_vars <- predictor_terms[!grepl("ntercept", predictor_terms)] # remove the intercept
  
  X_Fixed <- as.matrix(X_Fixed)
  X_rand <- as.matrix(X_rand)
  
  # check if the intercept is included in both the fixed and random parameters
  if("\\(Intercept\\)" %in% colnames(X_Fixed) && "\\(Intercept\\)" %in% colnames(X_rand)){
    print("Do not include the intercept in both the fixed parameters (in `formula`) and random parameters (in `rpar_formula`). Use `- 1` in the formula you want to remove the intercept from.")
    stop()
  }
  
  
  if(!is.null(rpardists)){ # check the random parameter distributions for the intercept (and correct, if needed)
    names(rpardists) <- gsub("intercept", "\\(Intercept\\)", names(rpardists)) # correct intercept name
    names(rpardists) <- gsub("constant", "\\(Intercept\\)", names(rpardists)) # correct intercept name
  }
  
  # Check if the specified distributions include all specified random parameters and no extras
  if (!correlated && !is.null(rpardists)){
    prob = FALSE
    for (i in rand_terms){
      if(i %in% names(rpardists)){
        next
      }
      else{
        print(paste("Variable ", i, " is specified as random but is not included in the `rpardists`. Please include it or do not specify the distributions."))
        prob = TRUE
      }
    }
    
    for (i in names(rpardists)){
      if (i %in% rand_terms){
        next
      }
      else{
        print(paste("Variable ", i, " is included in `rpardists` but is not in the specified random parameters. Please include it as a random parameter or remove it from `rpardists`."))
        prob = TRUE
      }
    }
    if (prob) stop() # if a problem was identified, the instructions were printed and the function will now stop executing
  }
  
  nb_formula <- reformulate(nb_vars, response = y_name)
  
  x_fixed_names <- colnames(X_Fixed)
  rpar <- colnames(X_rand)
  
  hdraws <- halton_draws(ndraws, rpar, scrambled)
  
  if(!is.null(start.vals)){
    params <- unname(start.vals)
    Lparams <- length(params)
    Lrpar = length(rpar)
    start <- params
    x_names <- names(start.vals)
  }
  else{
    nb_model <- MASS::glm.nb(nb_formula, data)
    params <- coef(nb_model)
    Lparams <- length(params)
    Lrpar = length(rpar)
    
    if (length(rpar)<2){
      correlated = FALSE
    }
    
    start <- params
    # Make sure the start parameters are ordered correctly, including the location of the intercept
    varnameorder <- c(x_fixed_names, rpar)
    match_indices <- match(varnameorder, names(start))
    start <- start[match_indices] # correctly ordered
    
    x_rand_names_mean <- paste0(rpar, ':Mean')
    x_names = c(x_fixed_names, x_rand_names_mean)
    
    if (correlated){
      randparam_means = tail(start, Lrpar)
      rparam_var <- abs(randparam_means)/2
      rparam_var <- diag(rparam_var)
      Chl <- chol(rparam_var)
      
      for (i in 1:length(rpar)){
        for (j in 1:length(rpar)){
          if (i >= j){
            start <- append(start, Chl[j,i])
            x_names <- append(x_names, paste('Cholesky Value for' ,paste(rpar[j], rpar[i], sep=":")))
          }
        }
      }
    }
    else{
      start <- append(start, rep(sd.start, length(rpar)))
      x_rand_names_sd <- paste0(rpar, ':St. Dev.')
      x_names <- append(x_names, x_rand_names_sd)
    }
    start <- append(start, log(0.1)) # initial log of overdispersion parameter
    x_names <- append(x_names, 'ln(alpha)')
    
    if (form=='nbp'){
      start <- append(start, 1.5) # initial value for parameter P
      x_names <- append(x_names, 'P')
    }
    names(start) <- x_names
  }
  
  # Gradient Function
  gradient_rpnb <- function(beta, y, X_Fixed, X_rand, ndraws, rpar, correlated, form, hdraws, rpardists) {
    N_fixed = ncol(X_Fixed)
    N_rand = length(rpar)
    
    coefs <- as.array(beta)
    fixed_coefs <- head(coefs, N_fixed)
    h <- head(coefs, (N_fixed + N_rand))
    random_coefs_means <- tail(h, N_rand)
    
    if (form == 'nbp') {
      dist_params <- tail(coefs, 2)
      log_alpha <- dist_params[1]
      p <- dist_params[2]
    } else {
      dist_params <- tail(coefs, 1)
      log_alpha <- dist_params[1]
      p <- NULL
    }
    
    alpha <- exp(log_alpha)
    mu_fixed <- exp(X_Fixed %*% fixed_coefs)
    
    if (length(rpar) == 1) {
      rand_sdevs <- coefs[length(coefs) - 1]
    } else {
      numtail <- length(coefs) - N_fixed - N_rand
      t <- tail(coefs, numtail)
      if (form == 'nbp') t <- head(t, -2)
      else t <- head(t, -1)
    }
    
    # Generate and scale random draws
    if (length(rpar) > 1) {
      if (correlated) {
        chol_vals <- t
        Ch <- matrix(0, N_rand, N_rand)
        counter = 1
        for (i in 1:N_rand) {
          for (j in 1:N_rand) {
            if (j <= i) {
              Ch[j, i] <- chol_vals[counter]
              counter <- counter + 1
            }
          }
        }
        scaled_draws <- qnorm(hdraws) %*% Ch
        draws <- apply(scaled_draws, 1, function(x) x + random_coefs_means)
      } else {
        rand_sdevs <- t
        draws <- hdraws
        
        if (is.null(rpardists)) {
          draws <- apply(hdraws, 1, function(x) stats::qnorm(x, random_coefs_means, rand_sdevs))
        } else {
          counter = 1
          for (i in rpar) {
            if (rpardists[i] == "ln") {
              draws[, counter] <- stats::qlnorm(hdraws[, counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
            } else if (rpardists[i] == "t") {
              draws[, counter] <- qtri(hdraws[, counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
            } else if (rpardists[i] == "u") {
              draws[, counter] <- random_coefs_means[counter] + (hdraws[, counter] - 0.5) * abs(rand_sdevs[counter])
            } else if (rpardists[i] == "g") {
              draws[, counter] <- stats::qgamma(hdraws[, counter], shape = random_coefs_means[counter]^2 / (rand_sdevs[counter]^2),
                                                rate = random_coefs_means[counter] / (rand_sdevs[counter]^2))
            } else {
              draws[, counter] <- stats::qnorm(hdraws[, counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
            }
            counter = counter + 1
          }
        }
        draws <- t(draws)
      }
      xb_rand_mat <- crossprod(t(X_rand), draws)
    } else {
      if (is.null(rpardists)) {
        scaled_draws <- hdraws * rand_sdevs
        draws <- scaled_draws + random_coefs_means[1]
      } else {
        if (rpardists[1] == "ln") {
          draws <- stats::qlnorm(hdraws, random_coefs_means, abs(rand_sdevs))
        } else if (rpardists[1] == "t") {
          draws <- qtri(hdraws, random_coefs_means, abs(rand_sdevs))
        } else if (rpardists[1] == "u") {
          draws <- random_coefs_means + (hdraws - 0.5) * abs(rand_sdevs)
        } else if (rpardists[1] == "g") {
          draws <- stats::qgamma(hdraws, shape = random_coefs_means^2 / (rand_sdevs^2),
                                 rate = random_coefs_means / (rand_sdevs^2))
        } else {
          draws <- stats::qnorm(hdraws, random_coefs_means, abs(rand_sdevs))
        }
      }
      xb_rand_mat <- sapply(draws, function(x) X_rand * x)
    }
    
    rpar_mat <- exp(xb_rand_mat)
    pred_mat <- apply(rpar_mat, 2, function(x) x * mu_fixed)
    prob_mat <- apply(pred_mat, 2, nb_prob, y = y, alpha = alpha, p = p)
    probs <- rowMeans(prob_mat)
    
    y_minus_mu <- y - mu_fixed
    
    if (form == 'nb2') {
      grad_beta <- t(X_Fixed) %*% diag(as.vector(y_minus_mu / (mu_fixed * (1 + alpha))))
      grad_alpha <- alpha * (log(alpha + mu_fixed) - log(alpha) + log(mu_fixed) - y / (alpha + mu_fixed))
      grad_alpha <- as.vector(grad_alpha)
      grad <- t(rbind(grad_beta, grad_alpha))
    } else if (form == 'nb1') {
      grad_beta <- t(X_Fixed) %*% diag(as.vector(y_minus_mu / (mu_fixed * (1 + 1 / alpha))))
      grad_alpha <- -mu_fixed / alpha + y * (log(mu_fixed) - log(mu_fixed + mu_fixed / alpha))
      grad_alpha <- as.vector(grad_alpha)
      grad <- t(rbind(grad_beta, grad_alpha))
    } else { # nbp
      grad_beta <- t(X_Fixed) %*% diag(as.vector(y_minus_mu / (mu_fixed^(2 - p) / alpha + mu_fixed)))
      grad_alpha <- -mu_fixed^(2 - p) / alpha + y * (log(mu_fixed) - log(mu_fixed^(2 - p) + mu_fixed / alpha))
      grad_alpha <- as.vector(grad_alpha)
      grad_p <- y * log(mu_fixed / (mu_fixed + alpha * mu_fixed^(2 - p))) - mu_fixed^(2 - p) * log(mu_fixed)
      grad_p <- as.vector(grad_p)
      grad <- t(rbind(grad_beta, grad_alpha, grad_p))
    }
    
    return(grad)
  }
  
  
  # Hessian Function
  hessian_rpnb <- function(beta, y, X_Fixed, X_rand, ndraws, rpar, correlated, form, hdraws, rpardists) {
    N_fixed = ncol(X_Fixed)
    N_rand = length(rpar)
    
    coefs <- as.array(beta)
    fixed_coefs <- head(coefs, N_fixed)
    h <- head(coefs, (N_fixed + N_rand))
    random_coefs_means <- tail(h, N_rand)
    
    if (form == 'nbp') {
      dist_params <- tail(coefs, 2)
      log_alpha <- dist_params[1]
      p <- dist_params[2]
    } else {
      dist_params <- tail(coefs, 1)
      log_alpha <- dist_params[1]
      p <- NULL
    }
    
    alpha <- exp(log_alpha)
    mu_fixed <- exp(X_Fixed %*% fixed_coefs)
    
    if (length(rpar) == 1) {
      rand_sdevs <- coefs[length(coefs) - 1]
    } else {
      numtail <- length(coefs) - N_fixed - N_rand
      t <- tail(coefs, numtail)
      if (form == 'nbp') t <- head(t, -2)
      else t <- head(t, -1)
    }
    
    # Generate and scale random draws
    if (length(rpar) > 1) {
      if (correlated) {
        chol_vals <- t
        Ch <- matrix(0, N_rand, N_rand)
        counter = 1
        for (i in 1:N_rand) {
          for (j in 1:N_rand) {
            if (j <= i) {
              Ch[j, i] <- chol_vals[counter]
              counter <- counter + 1
            }
          }
        }
        scaled_draws <- qnorm(hdraws) %*% Ch
        draws <- apply(scaled_draws, 1, function(x) x + random_coefs_means)
      } else {
        rand_sdevs <- t
        draws <- hdraws
        
        if (is.null(rpardists)) {
          draws <- apply(hdraws, 1, function(x) stats::qnorm(x, random_coefs_means, rand_sdevs))
        } else {
          counter = 1
          for (i in rpar) {
            if (rpardists[i] == "ln") {
              draws[, counter] <- stats::qlnorm(hdraws[, counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
            } else if (rpardists[i] == "t") {
              draws[, counter] <- qtri(hdraws[, counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
            } else if (rpardists[i] == "u") {
              draws[, counter] <- random_coefs_means[counter] + (hdraws[, counter] - 0.5) * abs(rand_sdevs[counter])
            } else if (rpardists[i] == "g") {
              draws[, counter] <- stats::qgamma(hdraws[, counter], shape = random_coefs_means[counter]^2 / (rand_sdevs[counter]^2),
                                                rate = random_coefs_means[counter] / (rand_sdevs[counter]^2))
            } else {
              draws[, counter] <- stats::qnorm(hdraws[, counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
            }
            counter = counter + 1
          }
        }
        draws <- t(draws)
      }
      xb_rand_mat <- crossprod(t(X_rand), draws)
    } else {
      if (is.null(rpardists)) {
        scaled_draws <- hdraws * rand_sdevs
        draws <- scaled_draws + random_coefs_means[1]
      } else {
        if (rpardists[1] == "ln") {
          draws <- stats::qlnorm(hdraws, random_coefs_means, abs(rand_sdevs))
        } else if (rpardists[1] == "t") {
          draws <- qtri(hdraws, random_coefs_means, abs(rand_sdevs))
        } else if (rpardists[1] == "u") {
          draws <- random_coefs_means + (hdraws - 0.5) * abs(rand_sdevs)
        } else if (rpardists[1] == "g") {
          draws <- stats::qgamma(hdraws, shape = random_coefs_means^2 / (rand_sdevs^2),
                                 rate = random_coefs_means / (rand_sdevs^2))
        } else {
          draws <- stats::qnorm(hdraws, random_coefs_means, abs(rand_sdevs))
        }
      }
      xb_rand_mat <- sapply(draws, function(x) X_rand * x)
    }
    
    rpar_mat <- exp(xb_rand_mat)
    pred_mat <- apply(rpar_mat, 2, function(x) x * mu_fixed)
    prob_mat <- apply(pred_mat, 2, nb_prob, y = y, alpha = alpha, p = p)
    probs <- rowMeans(prob_mat)
    
    y_minus_mu <- y - mu_fixed
    
    if (form == 'nb2') {
      W <- diag(as.vector(mu_fixed / (mu_fixed + alpha * mu_fixed)))
      H_beta <- -t(X_Fixed) %*% W %*% X_Fixed
      H_alpha <- matrix(-sum(alpha^2 / ((alpha + mu_fixed)^2)), ncol = 1, nrow = 1)
      H <- rbind(cbind(H_beta, matrix(0, ncol = 1, nrow = nrow(H_beta))), cbind(matrix(0, nrow = 1, ncol = ncol(H_beta)), H_alpha))
    } else if (form == 'nb1') {
      W <- diag(as.vector(mu_fixed / (mu_fixed / alpha + mu_fixed)))
      H_beta <- -t(X_Fixed) %*% W %*% X_Fixed
      H_alpha <- matrix(-sum(mu_fixed^2 / ((mu_fixed / alpha + mu_fixed)^2)), ncol = 1, nrow = 1)
      H <- rbind(cbind(H_beta, matrix(0, ncol = 1, nrow = nrow(H_beta))), cbind(matrix(0, nrow = 1, ncol = ncol(H_beta)), H_alpha))
    } else { # nbp
      W <- diag(as.vector(mu_fixed^(2 - p) / (mu_fixed^(2 - p) / alpha + mu_fixed)))
      H_beta <- -t(X_Fixed) %*% W %*% X_Fixed
      H_alpha <- matrix(-sum(mu_fixed^(2 - p) * alpha^2 / ((mu_fixed^(2 - p) + alpha * mu_fixed)^2)), ncol = 1, nrow = 1)
      H_p <- matrix(-sum((mu_fixed^(2 - p) * log(mu_fixed) * (2 - p))^2 / ((mu_fixed^(2 - p) / alpha + mu_fixed)^2)), ncol = 1, nrow = 1)
      H <- rbind(
        cbind(H_beta, matrix(0, ncol = 2, nrow = nrow(H_beta))),
        cbind(matrix(0, nrow = 2, ncol = ncol(H_beta)), diag(c(H_alpha, H_p)))
      )
    }
    
    return(H)
  }
  
  # Main function for computing likelihoods
  p_nb_rp <- function(p, y, X_Fixed, X_rand, ndraws, rpar, correlated, est_method){
    if (!correlated) exact.gradient=TRUE else exact.gradient=FALSE # use numerical gradient if using correlated random parameters
    N_fixed = length(x_fixed_names)
    N_rand = length(rpar)
    coefs <- as.array(p)
    fixed_coefs <- head(coefs,N_fixed)
    h <- head(coefs, (N_fixed + N_rand))
    random_coefs_means <- tail(h, N_rand)
    
    if (form=='nbp'){
      dist_params <- tail(coefs,2)
      log_alpha <- dist_params[1]
      p <- dist_params[2]
    } else{
      dist_params <- tail(coefs,1)
      log_alpha <- dist_params[1]
      p <- NULL
    }
    
    alpha <- exp(log_alpha)
    mu_fixed <- exp(X_Fixed %*% fixed_coefs)
    
    if(length(rpar)==1){
      rand_sdevs <- coefs[length(coefs)-1]
    }else{
      numtail <- length(coefs) - N_fixed - N_rand
      t <- tail(coefs, numtail)
      if (form=='nbp') t <- head(t,-2)
      else t <- head(t,-1)
    }
    
    # generate and scale random draws
    if (length(rpar)>1){
      if (correlated){ # Generate correlated random draws
        chol_vals <- t
        Ch <- matrix(0, N_rand, N_rand)
        counter = 1
        for (i in 1:N_rand){
          for (j in 1:N_rand){
            if (j<=i){
              Ch[j,i] <- chol_vals[counter]
              counter <- counter + 1
            }
          }
        }
        scaled_draws <- qnorm(hdraws) %*% Ch
        draws <- apply(scaled_draws, 1, function(x) x + random_coefs_means)
      }
      else{
        rand_sdevs <- t
        draws <- hdraws #initialize the matrix
        
        if (is.null(rpardists)){
          draws <- apply(hdraws, 1, function(x) stats::qnorm(x, random_coefs_means, rand_sdevs))
        }
        else{
          for (i in rpar){
            counter=1
            if (rpardists[i]=="ln"){
              draws[,counter] <- stats::qlnorm(hdraws[,counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
              counter=counter+1
            }
            else if (rpardists[i]=="t"){
              draws[,counter] <- qtri(hdraws[,counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
              counter=counter+1
            }
            else if (rpardists[i]=="u"){
              draws[,counter] <- random_coefs_means[counter] + (hdraws[,counter] - 0.5)*abs(rand_sdevs[counter])
              counter=counter+1
            }
            else if (rpardists[i]=="g"){
              draws[,counter] <- stats::qgamma(hdraws[,counter], shape=random_coefs_means[counter]^2/(rand_sdevs[counter]^2), 
                                               rate=random_coefs_means[counter]/(rand_sdevs[counter]^2))
              counter=counter+1
            }
            else{
              draws[,counter] <- stats::qnorm(hdraws[,counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
              counter=counter+1
            }
          }
        }
        draws <- t(draws)
      }
      xb_rand_mat <- crossprod(t(X_rand), draws)
    }
    else{
      if (is.null(rpardists)){
        scaled_draws <- hdraws * rand_sdevs
        draws <- scaled_draws + random_coefs_means[1]
      }
      else{
        if (rpardists[1]=="ln"){
          draws <- stats::qlnorm(hdraws, random_coefs_means, abs(rand_sdevs))
        }
        else if (rpardists[1]=="t"){
          draws <- qtri(hdraws, random_coefs_means, abs(rand_sdevs))
        }
        else if (rpardists[1]=="u"){
          draws <- random_coefs_means + (hdraws-0.5)*abs(rand_sdevs)
        }
        else if (rpardists[1]=="g"){
          draws <- stats::qgamma(hdraws, shape=random_coefs_means^2/(rand_sdevs^2), 
                                 rate=random_coefs_means/(rand_sdevs^2))
        }
        else{
          draws <- stats::qnorm(hdraws, random_coefs_means, abs(rand_sdevs))
        }
        
      }
      xb_rand_mat <- sapply(draws, function(x) X_rand * x)
    }
    
    rpar_mat <- exp(xb_rand_mat)
    pred_mat <- apply(rpar_mat, 2, function(x) x * mu_fixed)
    prob_mat <- apply(pred_mat, 2, nb_prob, y = y, alpha = alpha, p=p) # Pitr
    probs <- rowMeans(prob_mat) # Pi
    
    ll <- sum(log(probs))
    
    if (est_method == 'bhhh' || method == 'BHHH'){
      return(log(probs))
    } else{return(ll)}
  }
  fit <- maxLik::maxLik(reg.run,
                        start = full_start,
                        grad = if (method == 'BHHH') gradient_rpnb else function(...) colSums(gradient_rpnb(...)),,
                        hess = hessian_rpnb,
                        y = y,
                        X = X,
                        method = method,
                        control = list(iterlim = max.iters, printLevel = print.level))
  beta_est <- fit$estimate
  
  betas <- split(beta_est, ceiling(seq_along(beta_est) / modparams))
  beta_pred <- as.vector(unlist(betas[1]))
  
  if (is.null(ln.alpha.formula)) {
    x_names <- append(x_names, 'ln(alpha)')
  } else {
    x_names <- append(x_names, paste('ln(alpha): ', alpha_names))
  }
  
  if (form == 'nbp') {
    x_names <- append(x_names, 'P')
  }
  
  names(fit$estimate) <- x_names
  fit$beta_pred <- beta_pred # save coefficients for predictions
  fit$formula <- formula
  fit$form <- form
  fit$modelType <- "nbg"
  fit$predictions <- exp(X %*% beta_pred)
  fit$observed <- y
  fit$residuals <- y - fit$predictions
  fit$LL <- fit$maximum # The log-likelihood of the model
  
  return(fit)
}

# Function for computing the Hessian
hessian_rpnb <- function(beta, y, X_Fixed, X_rand, ndraws, rpar, correlated, form, hdraws, rpardists) {
  N_fixed = ncol(X_Fixed)
  N_rand = length(rpar)
  
  coefs <- as.array(beta)
  fixed_coefs <- head(coefs, N_fixed)
  h <- head(coefs, (N_fixed + N_rand))
  random_coefs_means <- tail(h, N_rand)
  
  if (form == 'nbp') {
    dist_params <- tail(coefs, 2)
    log_alpha <- dist_params[1]
    p <- dist_params[2]
  } else {
    dist_params <- tail(coefs, 1)
    log_alpha <- dist_params[1]
    p <- NULL
  }
  
  alpha <- exp(log_alpha)
  mu_fixed <- exp(X_Fixed %*% fixed_coefs)
  
  if (length(rpar) == 1) {
    rand_sdevs <- coefs[length(coefs) - 1]
  } else {
    numtail <- length(coefs) - N_fixed - N_rand
    t <- tail(coefs, numtail)
    if (form == 'nbp') t <- head(t, -2)
    else t <- head(t, -1)
  }
  
  # generate and scale random draws
  if (length(rpar) > 1) {
    if (correlated) { # Generate correlated random draws
      chol_vals <- t
      Ch <- matrix(0, N_rand, N_rand)
      counter = 1
      for (i in 1:N_rand) {
        for (j in 1:N_rand) {
          if (j <= i) {
            Ch[j, i] <- chol_vals[counter]
            counter <- counter + 1
          }
        }
      }
      scaled_draws <- qnorm(hdraws) %*% Ch
      draws <- apply(scaled_draws, 1, function(x) x + random_coefs_means)
    } else {
      rand_sdevs <- t
      draws <- hdraws #initialize the matrix
      
      if (is.null(rpardists)) {
        draws <- apply(hdraws, 1, function(x) stats::qnorm(x, random_coefs_means, rand_sdevs))
      } else {
        counter = 1
        for (i in rpar) {
          if (rpardists[i] == "ln") {
            draws[, counter] <- stats::qlnorm(hdraws[, counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
          } else if (rpardists[i] == "t") {
            draws[, counter] <- qtri(hdraws[, counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
          } else if (rpardists[i] == "u") {
            draws[, counter] <- random_coefs_means[counter] + (hdraws[, counter] - 0.5) * abs(rand_sdevs[counter])
          } else if (rpardists[i] == "g") {
            draws[, counter] <- stats::qgamma(hdraws[, counter], shape = random_coefs_means[counter]^2 / (rand_sdevs[counter]^2),
                                              rate = random_coefs_means[counter] / (rand_sdevs[counter]^2))
          } else {
            draws[, counter] <- stats::qnorm(hdraws[, counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
          }
          counter = counter + 1
        }
      }
      draws <- t(draws)
    }
    xb_rand_mat <- crossprod(t(X_rand), draws)
  } else {
    if (is.null(rpardists)) {
      scaled_draws <- hdraws * rand_sdevs
      draws <- scaled_draws + random_coefs_means[1]
    } else {
      if (rpardists[1] == "ln") {
        draws <- stats::qlnorm(hdraws, random_coefs_means, abs(rand_sdevs))
      } else if (rpardists[1] == "t") {
        draws <- qtri(hdraws, random_coefs_means, abs(rand_sdevs))
      } else if (rpardists[1] == "u") {
        draws <- random_coefs_means + (hdraws - 0.5) * abs(rand_sdevs)
      } else if (rpardists[1] == "g") {
        draws <- stats::qgamma(hdraws, shape = random_coefs_means^2 / (rand_sdevs^2),
                               rate = random_coefs_means / (rand_sdevs^2))
      } else {
        draws <- stats::qnorm(hdraws, random_coefs_means, abs(rand_sdevs))
      }
    }
    xb_rand_mat <- sapply(draws, function(x) X_rand * x)
  }
  
  rpar_mat <- exp(xb_rand_mat)
  pred_mat <- apply(rpar_mat, 2, function(x) x * mu_fixed)
  prob_mat <- apply(pred_mat, 2, nb_prob, y = y, alpha = alpha, p = p) # Pitr
  probs <- rowMeans(prob_mat) # Pi
  
  y_minus_mu <- y - mu_fixed
  
  if (form == 'nb2') {
    W <- diag(as.vector(mu_fixed / (mu_fixed + alpha * mu_fixed)))
    H_beta <- -t(X_Fixed) %*% W %*% X_Fixed
    H_alpha <- matrix(-sum(alpha^2 / ((alpha + mu_fixed)^2)), ncol = 1, nrow = 1)
    H <- rbind(cbind(H_beta, matrix(0, ncol = 1, nrow = nrow(H_beta))), cbind(matrix(0, nrow = 1, ncol = ncol(H_beta)), H_alpha))
  } else if (form == 'nb1') {
    W <- diag(as.vector(mu_fixed / (mu_fixed / alpha + mu_fixed)))
    H_beta <- -t(X_Fixed) %*% W %*% X_Fixed
    H_alpha <- matrix(-sum(mu_fixed^2 / ((mu_fixed / alpha + mu_fixed)^2)), ncol = 1, nrow = 1)
    H <- rbind(cbind(H_beta, matrix(0, ncol = 1, nrow = nrow(H_beta))), cbind(matrix(0, nrow = 1, ncol = ncol(H_beta)), H_alpha))
  } else { # nbp
    W <- diag(as.vector(mu_fixed^(2 - p) / (mu_fixed^(2 - p) / alpha + mu_fixed)))
    H_beta <- -t(X_Fixed) %*% W %*% X_Fixed
    H_alpha <- matrix(-sum(mu_fixed^(2 - p) * alpha^2 / ((mu_fixed^(2 - p) + alpha * mu_fixed)^2)), ncol = 1, nrow = 1)
    H_p <- matrix(-sum((mu_fixed^(2 - p) * log(mu_fixed) * (2 - p))^2 / ((mu_fixed^(2 - p) / alpha + mu_fixed)^2)), ncol = 1, nrow = 1)
    H <- rbind(
      cbind(H_beta, matrix(0, ncol = 2, nrow = nrow(H_beta))),
      cbind(matrix(0, nrow = 2, ncol = ncol(H_beta)), diag(c(H_alpha, H_p)))
    )
  }
  
  return(H)
}

# main function for estimating log-likelihoods
p_nb_rp <- function(p, y, X_Fixed, X_rand, ndraws, rpar, correlated, est_method){
  if (!correlated) exact.gradient=TRUE else exact.gradient=FALSE # use numerical gradient if using correlated random parameters
  N_fixed = length(x_fixed_names)
  N_rand = length(rpar)
  coefs <- as.array(p)
  fixed_coefs <- head(coefs,N_fixed)
  h <- head(coefs, (N_fixed + N_rand))
  random_coefs_means <- tail(h, N_rand)
  
  if (form=='nbp'){
    dist_params <- tail(coefs,2)
    log_alpha <- dist_params[1]
    p <- dist_params[2]
  } else{
    dist_params <- tail(coefs,1)
    log_alpha <- dist_params[1]
    p <- NULL
  }
  
  alpha <- exp(log_alpha)
  mu_fixed <- exp(X_Fixed %*% fixed_coefs)
  
  if(length(rpar)==1){
    rand_sdevs <- coefs[length(coefs)-1]
  }else{
    numtail <- length(coefs) - N_fixed - N_rand
    t <- tail(coefs, numtail)
    if (form=='nbp') t <- head(t,-2)
    else t <- head(t,-1)
  }
  
  # generate and scale random draws
  if (length(rpar)>1){
    if (correlated){ # Generate correlated random draws
      chol_vals <- t
      Ch <- matrix(0, N_rand, N_rand)
      counter = 1
      for (i in 1:N_rand){
        for (j in 1:N_rand){
          if (j<=i){
            Ch[j,i] <- chol_vals[counter]
            counter <- counter + 1
          }
        }
      }
      scaled_draws <- qnorm(hdraws) %*% Ch
      draws <- apply(scaled_draws, 1, function(x) x + random_coefs_means)
    }
    else{
      rand_sdevs <- t
      draws <- hdraws #initialize the matrix
      
      if (is.null(rpardists)){
        draws <- apply(hdraws, 1, function(x) stats::qnorm(x, random_coefs_means, rand_sdevs))
      }
      else{
        for (i in rpar){
          counter=1
          if (rpardists[i]=="ln"){
            draws[,counter] <- stats::qlnorm(hdraws[,counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
            counter=counter+1
          }
          else if (rpardists[i]=="t"){
            draws[,counter] <- qtri(hdraws[,counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
            counter=counter+1
          }
          else if (rpardists[i]=="u"){
            draws[,counter] <- random_coefs_means[counter] + (hdraws[,counter] - 0.5)*abs(rand_sdevs[counter])
            counter=counter+1
          }
          else if (rpardists[i]=="g"){
            draws[,counter] <- stats::qgamma(hdraws[,counter], shape=random_coefs_means[counter]^2/(rand_sdevs[counter]^2),
                                             rate=random_coefs_means[counter]/(rand_sdevs[counter]^2))
            counter=counter+1
          }
          else{
            draws[,counter] <- stats::qnorm(hdraws[,counter], random_coefs_means[counter], abs(rand_sdevs[counter]))
            counter=counter+1
          }
        }
      }
      draws <- t(draws)
    }
    xb_rand_mat <- crossprod(t(X_rand), draws)
  }
  else{
    if (is.null(rpardists)){
      scaled_draws <- hdraws * rand_sdevs
      draws <- scaled_draws + random_coefs_means[1]
    }
    else{
      if (rpardists[1]=="ln"){
        draws <- stats::qlnorm(hdraws, random_coefs_means, abs(rand_sdevs))
      }
      else if (rpardists[1]=="t"){
        draws <- qtri(hdraws, random_coefs_means, abs(rand_sdevs))
      }
      else if (rpardists[1]=="u"){
        draws <- random_coefs_means + (hdraws-0.5)*abs(rand_sdevs)
      }
      else if (rpardists[1]=="g"){
        draws <- stats::qgamma(hdraws, shape=random_coefs_means^2/(rand_sdevs^2),
                               rate=random_coefs_means/(rand_sdevs^2))
      }
      else{
        draws <- stats::qnorm(hdraws, random_coefs_means, abs(rand_sdevs))
      }
      
    }
    xb_rand_mat <- sapply(draws, function(x) X_rand * x)
  }
  
  rpar_mat <- exp(xb_rand_mat)
  pred_mat <- apply(rpar_mat, 2, function(x) x * mu_fixed)
  prob_mat <- apply(pred_mat, 2, nb_prob, y = y, alpha = alpha, p=p) # Pitr
  probs <- rowMeans(prob_mat) # Pi
  
  ll <- sum(log(probs))
  
  if (est_method == 'bhhh' || method == 'BHHH'){
    return(log(probs))
  } else{return(ll)}
  
  
  fit <- maxLik::maxLik(
    logLik = p_nb_rp,
    grad = if (method == 'BHHH') gradient_rpnb else function(...) colSums(gradient_rpnb(...)),
    hess = hessian_rpnb,
    start = start,
    y = y,
    X_Fixed = X_Fixed,
    X_rand = X_rand,
    ndraws = ndraws,
    rpar = rpar,
    correlated = correlated,
    form = form,
    hdraws = hdraws,
    rpardists = rpardists,
    method = method,
    control = list(iterlim = max.iters, printLevel = print.level)
  )
  
  N_fixed = length(x_fixed_names)
  N_rand = length(rpar)
  
  param.splits <- as.factor(ifelse((grepl("St. Dev", x_names) + grepl("Cholesky", x_names)==1), "rpr", "coef"))
  
  coefs <- as.array(fit$estimate)
  
  split.coefs <- split(coefs, param.splits)
  
  t <- split.coefs$coef
  sd <- split.coefs$rpr
  
  if (correlated){
    if(form=='nbp'){
      chol_vals <- head(t,-2)
    }
    else{
      chol_vals <- head(t,-1)
    }
    Cholesky <- matrix(0, N_rand, N_rand)
    counter = 1
    for (i in 1:N_rand){
      for (j in 1:N_rand){
        if (j<=i){
          Cholesky[j,i] <- chol_vals[counter]
          counter <- counter + 1
        }
      }
    }
    
    Covariance <- t(Cholesky) %*% Cholesky
    Correlation <- cov2cor(Covariance)
  }
  
  if(form =='nbp'){
    t <- tail(fit$estimate,2)
    alpha <- exp(t[1])
    P <- t[2]
  }else{
    alpha <- exp(tail(fit$estimate,1))
    P <- NULL
  }
  
  #names(fit$estimate) <- x_names
  if(correlated){
    fit$Cholesky <- Cholesky
    fit$Covariance <- Covariance
    fit$Correlation <- Correlation
    fit$sd <- as.vector(sqrt(diag(Covariance)))
  }else{
    if(form=='nbp'){
      b.coefs <- head(coefs,-2)
      parms <- split(b.coefs, f=param.splits[1:(length(param.splits)-2)])
    }else{
      b.coefs <- head(coefs,-1)
      parms <- split(b.coefs, f=param.splits)
    }
    fit$sd <- abs(as.vector(parms$rpr))
  }
  
  fit$coefs <- coefs[1:(N_fixed+N_rand)]
  fit$alpha = alpha
  fit$P <- P
  fit$x_names <- as.list(x_names)
  fit$estimate <- ifelse(grepl("St.", names(fit$estimate)), abs(fit$estimate ), fit$estimate)
  fit$formula <- formula
  fit$x_names <- x_names
  fit$rpar_formula <- rpar_formula
  fit$scrambled <- scrambled
  fit$numdraws <- ndraws
  fit$correlated <- correlated
  fit$form = form
  if (!correlated){
    fit$rpardists = rpardists
    names(fit$sd) <- colnames(X_rand)
  }else{
    dst <- as.list(rep("n", length(colnames(X_rand))))
    names(dst) <- colnames(X_rand)
    fit$rpardists = dst
  }
  
  names(fit$estimate) <- x_names
  
  fit$modelType <- "rpnb"
  
  return(fit)
}