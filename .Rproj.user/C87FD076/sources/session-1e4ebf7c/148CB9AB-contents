#' Poisson-Generalized-Exponential Regression
#' 
#' @name poisGE
#' @param formula an R formula.
#' @param data a dataframe that has all of the variables in the \code{formula} and \code{rpar_formula}. This can be the data used for estimating the model or another dataframe,
#' @param ln.scale.formula an optional formula for using independent variables to estimate the natural log of the scale parameter.
#' @param ndraws the number of Halton draws to use for the integration over the lognormal distribution.
#' @param method a method to use for optimization in the maximum likelihood estimation. For options, see \code{\link[maxLik]{maxLik}}.
#' @param max.iters the maximum number of iterations to allow the optimization method to perform.
#' @param print.level determines the level of verbosity for printing details of the optimization as it is computed. A value of 0 does not print out any information, a value of 1 prints minimal information, and a value of 2 prints the most information.
#'
#' @details
#' This implements maximum simulated likelihood (MSL) to estimate a Poisson-Generalized Exponential regression model. The regression model has the flexibility to model the scale parameter as a function of independent variables, similar to the generalized negative binomial.
#'
#' Details of the distribution can be found with the function \code{\link{dpge}}
#' The t-statistics and p-values for the coefficients related to ln(sigma) are,
#' by default, testing if the coefficients are different from a value of 0. This
#' has little practical meaning given that they are coefficients for ln(sigma).
#' They are not testing if the coefficients have statistical significance in
#' terms of improvement over a Poisson model. The Likelihood-Ratio test results
#' provided in the output provide a test comparing if the Poisson-Lognormal
#' model provides a statistically significant improvement in model fit over the
#' Poisson model.
#'
#' @import nlme  maxLik  MASS  stats modelr
#' @include ppoisGE.R
#' 
#' @examples
#' # Generalized Poisson-Lognormal
#' data("washington_roads")
#' washington_roads$AADTover10k <- ifelse(washington_roads$AADT>10000,1,0)
#'
#' poisge.mod <- poisGE(Total_crashes ~ lnaadt + lnlength + speed50 +
#'                         ShouldWidth04 + AADTover10k,
#'                         ln.scale.formula = ~ lnaadt,
#'                         data=washington_roads[1:500,], 
#'                         ndraws = 10,
#'                         max.iters = 500, 
#'                         method = 'nm')
#' summary(poisge.mod)
#' 
#' @export
poisGE <- function(formula, data, ln.scale.formula = NULL, ndraws = 1500, 
                   method = 'BHHH', max.iters = 200, print.level = 0) {
  
  mod_df <- stats::model.frame(formula, data)
  X <- as.matrix(modelr::model_matrix(data, formula))
  y <- as.numeric(stats::model.response(mod_df))
  x_names <- colnames(X)
  n.coefs <- ncol(X)
  n.obs <- length(y)
  
  # Use the Poisson as starting values
  p_model <- MASS::glm.nb(formula, data = data)
  start <- unlist(p_model$coefficients)
  start <- append(start, 0) # Append ln(shape)
  
  if (is.null(ln.scale.formula)) {
    full_start <- append(start, 0) # Append ln(scale)
    S <- NULL
  } else {
    scale_X <- stats::model.matrix(ln.scale.formula, data)
    S <- as.matrix(scale_X)
    scale_names <- colnames(S)
    s_coefs <- rep(0, length(scale_names))
    full_start <- c(start, s_coefs)
  }
  
  modparams <- length(full_start) # total number of model parameters, including ln(shape) and ln(scale) or scale coefficients
  
  # Log-likelihood function
  logLikFun <- function(beta, y, X, S = NULL, ndraws) {
    coefs <- beta[1:n.coefs]
    shape <- exp(beta[(n.coefs + 1)])
    if (is.null(S)) {
      scale <- exp(beta[modparams])
    } else {
      scale_pars <- beta[(n.coefs + 2):modparams]
      scale <- exp(S %*% scale_pars)
    }
    
    predicted <- exp(X %*% coefs)
    probs <- dpge(x = y, mean = predicted, shape = shape, scale = scale, ndraws = ndraws)
    ll <- sum(log(probs))
    
    return(ll)
  }
  
  # Gradient function
  gradFun <- function(beta, y, X) {
    n.params <- length(beta)
    coefs <- beta[1:n.coefs]
    ln_shape <- beta[(n.coefs + 1)]
    shape <- exp(ln_shape)
    if (is.null(S)) {
      ln_scale <- beta[n.params]
      scale <- exp(ln_scale)
    } else {
      scale_pars <- beta[(n.coefs + 2):n.params]
      scale <- exp(S %*% scale_pars)
    }
    
    predicted <- exp(X %*% coefs)
    probs <- dpge(x = y, mean = predicted, shape = shape, scale = scale, ndraws = ndraws)
    
    grad_matrix <- matrix(0, n.obs, n.params)
    
    dL_dshape <- (y - predicted) / (predicted * shape) * shape  # Adjust for the log parameterization
    dL_dscale <- (y - predicted) / (predicted * scale) * scale  # Adjust for the log parameterization
    
    grad_matrix[,(n.coefs + 1)] <- dL_dshape 
    dL_dmu <- (y-predicted)/predicted
    
    for (k in 1:n.coefs){
      grad_matrix[,k] <- dL_dmu * X[,k]
    }
    
    if (is.null(S)) {
      grad_matrix[, n.params] <- dL_dscale
    } else {
      if ((n.params - n.coefs) == 1) {  # A single variable for the scale
        grad_matrix[, n.params] <- dL_dscale * S
      } else {
        dL_dscales <- apply(S,2,function(z) z*dL_dscale)
        grad_matrix[, (n.coefs+2):n.params] <- dL_dscales
      }
    }
    
    return(grad_matrix)
  }
  
  # Hessian function
  hessianFun <- function(beta, y, X) {
    n.params <- length(beta)
    coefs <- beta[1:n.coefs]
    ln_shape <- beta[(n.coefs + 1)]
    shape <- exp(ln_shape)
    if (is.null(S)) {
      ln_scale <- beta[n.params]
      scale <- exp(ln_scale)
    } else {
      scale_pars <- beta[(n.coefs + 2):n.params]
      scale <- exp(S %*% scale_pars)
    }
    
    predicted <- exp(X %*% coefs)
    probs <- dpge(x = y, mean = predicted, shape = shape, scale = scale, ndraws = ndraws)
    
    hessian_matrix <- matrix(0, n.params, n.params)
    
    dL_dshape <- (y - predicted) / (predicted * shape) * shape  # Adjust for the log parameterization
    dL_dscale <- (y - predicted) / (predicted * scale) * scale  # Adjust for the log parameterization
    
    d2L_dshape2 <- -((y - predicted) / (predicted * shape^2) * shape^2 + dL_dshape / shape)
    d2L_dscale2 <- -((y - predicted) / (predicted * scale^2) * scale^2 + dL_dscale / scale)
    
    hessian_matrix[(n.coefs + 1), (n.coefs + 1)] <- sum(d2L_dshape2)
    hessian_matrix[n.params, n.params] <- sum(d2L_dscale2)
    
    dL_dmu <- (y - predicted) / predicted
    d2L_dmu2 <- -(y / predicted^2)
    
    for (i in 1:n.coefs) {
      hessian_matrix[i, i] <- sum(d2L_dmu2 * X[, i]^2)
      hessian_matrix[i, (n.coefs + 1)] <- sum(dL_dmu * X[, i] * dL_dshape)
      hessian_matrix[(n.coefs + 1), i] <- hessian_matrix[i, (n.coefs + 1)]
      if (is.null(S)) {
        hessian_matrix[i, n.params] <- sum(dL_dmu * X[, i] * dL_dscale)
        hessian_matrix[n.params, i] <- hessian_matrix[i, n.params]
      } else {
        for (j in (n.coefs + 2):n.params) {
          dL_dscales <- apply(S, 2, function(z) z * dL_dscale)
          hessian_matrix[i, j] <- sum(dL_dmu * X[, i] * dL_dscales[, j - (n.coefs + 1)])
          hessian_matrix[j, i] <- hessian_matrix[i, j]
        }
      }
    }
    
    if (!is.null(S)) {
      d2L_dscales2 <- apply(S, 2, function(z) -(y - predicted) / (predicted * scale^2) * scale^2 + dL_dscale * z)
      for (i in (n.coefs + 2):n.params) {
        for (j in (n.coefs + 2):n.params) {
          hessian_matrix[i, j] <- sum(d2L_dscales2[, i - (n.coefs + 1)] * S[, j - (n.coefs + 1)])
        }
      }
    }
    
    return(hessian_matrix)
  }
  
  fit <- maxLik::maxLik(
    logLik = logLikFun,
    start = full_start,
    grad = if (method == 'BHHH') gradFun else function(...) colSums(gradFun(...)),
    hess=hessianFun,
    y = y,
    X = X,
    S = if (is.null(ln.scale.formula)) NULL else S,
    ndraws = ndraws,
    method = method,
    control = list(iterlim = max.iters, printLevel = print.level)
  )
  
  beta_est <- fit$estimate
  betas <- beta_est[1:n.coefs]
  beta_pred <- as.vector(unlist(betas))
  
  pred <- exp(X %*% beta_pred)
  
  beta_dist_params <- as.vector(beta_est[(n.coefs+1):length(beta_est)])
  shape <- exp(beta_dist_params[1])
  fit$shape <- shape
  if (is.null(ln.scale.formula)) {
    scale <- exp(beta_dist_params[2])
    fit$scale <- scale
  } else {
    scale_coefs <- beta_dist_params[2:length(beta_dist_params)]
    fit$scale_coefs <- scale_coefs
    scales <- exp(S %*% scale_coefs)
    fit$scales <- scales
  }
  
  x_names <- append(x_names, 'ln(shape)')
  if (is.null(ln.scale.formula)) {
    x_names <- append(x_names, 'ln(scale)')
  } else {
    x_names <- append(x_names, paste0('ln(scale):', scale_names))
  }
  
  names(fit$estimate) <- x_names
  fit$beta_pred <- beta_pred # save coefficients for predictions
  fit$formula <- formula
  fit$ln.scale.formula <- ln.scale.formula
  fit$modelType <- "Poisson-Generalized-Exponential"
  fit$predictions <- pred
  fit$observed <- y
  fit$residuals <- y - fit$predictions
  fit$LL <- fit$maximum # The log-likelihood of the model
  
  return(fit)
}

