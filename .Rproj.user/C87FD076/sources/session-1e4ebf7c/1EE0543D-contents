#' Function for estimating a variety of negative binomial models (NB-1, NB-2,
#' NB-P and generalized versions of each)
#'
#' @name nbg
#' @param formula an R formula.
#' @param data a dataframe that has all of the variables in the \code{formula}
#'   and \code{rpar_formula}. This can be the data used for estimating the model
#'   or another dataframe,
#' @param form the version of the negative binomial to estimate (\code{"nb2"}
#'   estimates the NB-2, \code{"nb1"} estimates the NB-1, \code{"nbp"} estimates
#'   the NB-P)
#' @param ln.alpha.formula an optional formula for using independent variables
#'   to estimate the natural log of the overdispersion parameter (makes the
#'   model a generalized negative binomial).
#' @param method a method to use for optimization in the maximum likelihood
#'   estimation. For options, see \code{\link[maxLik]{maxLik}},
#' @param max.iters the maximum number of iterations to allow the optimization
#'   method to perform.
#'
#' @details
#' The NB-1, NB-2, and NB-P versions of the negative binomial distribution
#'
#'
#' @import nlme  maxLik  MASS  stats modelr
#' 
#' @examples
#'
#' ## NB-P model
#' data("washington_roads")
#' washington_roads$AADTover10k <- ifelse(washington_roads$AADT>10000,1,0)
#'
#' nbp.base <- nbg(Total_crashes ~ lnaadt + lnlength + speed50 +
#'                     ShouldWidth04 + AADTover10k,
#'                     data=washington_roads, form = 'nbp', method = 'NM',
#'                     max.iters=3000)
#' summary(nbp.base)
#'
#' ## Generalized NB-P model
#'
#' nbp.overdispersion <- nbg(Total_crashes ~ lnaadt + lnlength + speed50 +
#'                                 ShouldWidth04 + AADTover10k,
#'                                 data=washington_roads,
#'                                 form = 'nbp',
#'                                 method = 'NM',
#'                                 max.iters=3000,
#'                                 ln.alpha.formula = ~ 1+lnlength)
#' summary(nbp.overdispersion)
#'
#' ## NB-1 Model
#' nb1.base <- nbg(Total_crashes ~ lnaadt + lnlength + speed50 +
#'                         ShouldWidth04 + AADTover10k,
#'                         data=washington_roads, form = 'nb1',
#'                         method = 'NM',
#'                         max.iters=3000)
#' summary(nb1.base)
#'
#' ## Generalize NB-1 Model
#' nb1.overdispersion <- nbg(Total_crashes ~ lnaadt + lnlength + speed50 +
#'                         ShouldWidth04 + AADTover10k,
#'                         data=washington_roads, form = 'nb1',
#'                         method = 'NM',
#'                         max.iters=3000, ln.alpha.formula = ~ 1+lnlength)
#' summary(nb1.overdispersion)
#'
#' ## NB-2 Model
#' nb2.base <- nbg(Total_crashes ~ lnaadt + lnlength + speed50 +
#'                         ShouldWidth04 + AADTover10k,
#'                         data=washington_roads, form = 'nb2',
#'                         method = 'NM',
#'                         max.iters=3000)
#' summary(nb2.base)
#'
#' ## Generalize NB-2 Model
#' nb2.overdispersion <- nbg(Total_crashes ~ lnaadt + lnlength + speed50 +
#'                         ShouldWidth04 + AADTover10k,
#'                         data=washington_roads, form = 'nb2',
#'                         method = 'NM',
#'                         max.iters=3000, ln.alpha.formula = ~ 1+lnlength)
#' summary(nb2.overdispersion)
#' 
#' @export
nbg <- function(formula, data, form = 'nb2', ln.alpha.formula = NULL, method = 'BHHH', max.iters=200) {
  
  mod_df <- stats::model.frame(formula, data)
  X <- as.matrix(modelr::model_matrix(data, formula))
  y <- as.numeric(stats::model.response(mod_df))
  x_names <- colnames(X)
  
  # Use the Poisson as starting values
  p_model <- MASS::glm.nb(formula, data = data)
  start <- unlist(p_model$coefficients)
  a <- log(1/p_model$theta)
  
  if (is.null(ln.alpha.formula)){
    if (!is.null(a)) {
      comb_start <- append(start, a)
      alpha_X <- NULL
      alpha_X_cols <- 1
    }
  }else{
    alpha_X <- stats::model.matrix(ln.alpha.formula, data)
    alpha_X_cols <- ncol(alpha_X)
    alpha_names <- colnames(alpha_X)
    a_coefs <- rep(0, length(alpha_names))
    a_coefs[1] <- a
    if (!is.null(a_coefs)) {
      comb_start <- c(start, a_coefs)
    }
  }
  
  if (is.null(ln.alpha.formula)) {
    x_names <- append(x_names, 'ln(alpha)')
  } else {
    x_names <- append(x_names, paste('ln(alpha): ', alpha_names))
  }

  if (form=='nbp') {
    full_start <- append(comb_start, 1.5)
    x_names <- append(x_names, 'P')
  } else{
    full_start <- comb_start
  }
  
  names(full_start) <- x_names
  
  modparams <- as.numeric(ncol(X)) # save the number of model coefficients, not including alpha or P
  
  nbp_prob <- function(observed, predicted, log_alpha, p) {
    alpha <- exp(log_alpha)
    mu <- predicted
    y <- observed
    if (form=='nb2'){
      return(stats::dnbinom(y, size = alpha, mu = mu))
    } else if (form=='nb1'){
      return(stats::dnbinom(y, size = mu/alpha, mu = mu))
    } else{
      return(stats::dnbinom(y, size = (mu^(2-p))/alpha, mu = mu))
    }
  }
  
  reg.run <- function(params, y, X, alpha_X){
    coefs <- params[1:modparams]
    if (is.null(alpha_X)) {
      log_alpha <- params[(modparams + 1)]
    } else {
      alpha_coefs <- params[(modparams + 1):(modparams+alpha_X_cols)]

      log_alpha <- alpha_X %*% alpha_coefs
    }
    alpha <- exp(log_alpha)
    mu <- exp(X %*% coefs)
    
    if (form=='nbp') p <- params[length(params)] else p <- NULL
    
    predicted <- exp(X %*% coefs)
    
    probs <- nbp_prob(y, predicted, log_alpha, p)
    
    ll <- sum(log(probs))
    if (method == 'bhhh' | method == 'BHHH'){
      return(log(probs))
    } else{return(ll)}
  }

  # Gradient Function
  gradFun <- function(params, y, X, alpha_X) {
    coefs <- params[1:ncol(X)]
    mu <- exp(X %*% coefs)
    
    if (form == 'nbp'){
      p <- params[length(params)]
    }
    else if (form == 'nb1'){
      p <- 1
    }
    else{
      p <- 2
    }
    
    if (is.null(alpha_X)) {
      log_alpha <- params[ncol(X) + 1]
      alpha <- exp(log_alpha)
    } else {
      alpha_coefs <- params[(ncol(X) + 1):(ncol(X) + ncol(alpha_X))]
      log_alpha <- alpha_X %*% alpha_coefs
      alpha <- exp(log_alpha)
    }
    
    R <- mu^(2 - p) / alpha
    S_sum <- y + R
    M_sum <- mu + R
    
    if (form!="nb2"){
      ln_alpha_grad_cons <- R*(alpha*y-alpha*mu+alpha*R*(log(M_sum)-log(R)-digamma(S_sum)+digamma(R)))/(alpha*M_sum)
      beta_grad_cons <- R*(alpha*y*(p-1)-alpha*mu+(p-2)*(alpha*M_sum*(log(M_sum)-log(R)-digamma(S_sum)+digamma(R))+mu^(2-p)))/(alpha*M_sum)
    }
    else{
      ln_alpha_grad_cons <- ((y-mu)+(alpha*mu+1)*(log(alpha*mu+1)-digamma(y+1/alpha)+digamma(1/alpha)))/(mu+1/alpha)
      beta_grad_cons <- (y-mu)/(alpha*mu+1)
    }
    
    
    if (form == 'nbp') grad_p <- p*log(mu)*ln_alpha_grad_cons
    
    if (!is.null(alpha_X)){
      if (ncol(alpha_X)>1){
        grad_alpha <- alpha_X
        for (i in ncol(alpha_X)){
          grad_alpha[,i] <- alpha_X[,i] * ln_alpha_grad_cons 
        }
      }
      else{
        grad_alpha <- alpha_X*ln_alpha_grad_cons
      }
    }
    else{
      grad_alpha <- ln_alpha_grad_cons
    }
    
    grad_beta <- X
    
    for (i in 1:ncol(X)){
      grad_beta[,i] <- X[,i] * beta_grad_cons
    }
    
    if (form == 'nbp'){
      return(cbind(grad_beta, grad_alpha, grad_p))
    }
    else{
      return(cbind(grad_beta, grad_alpha))
    }
  }
  
  # Hessian Function
  hessianFun <- function(params, y, X, alpha_X) {
    coefs <- params[1:ncol(X)]
    mu <- exp(X %*% coefs)
    
    if (form == 'nbp') {
      p <- params[length(params)]
    } else if (form == 'nb1') {
      p <- 1
    } else if (form == 'nb2')  {
      p <- 2
    }
    
    if (is.null(alpha_X)) {
      log_alpha <- params[ncol(X) + 1]
      alpha <- exp(log_alpha)
    } else {
      alpha_coefs <- params[(ncol(X) + 1):(ncol(X) + ncol(alpha_X))]
      log_alpha <- alpha_X %*% alpha_coefs
      alpha <- exp(log_alpha)
    }
    
    R <- mu^(2 - p) / alpha
    S_sum <- y + R
    M_sum <- mu + R
    
    # Hessian with respect to ln(P)
    if (form == 'nbp') {
      lnP_hessian <- sum(-1*p * log(mu) * (
        p * (
          -p * mu^(2 - p) * M_sum * (-mu + y - M_sum * (log(R) - log(M_sum) - digamma(R) + digamma(S_sum))) +
            mu^(4 - 2 * p) * (mu - y + M_sum * (log(R) - log(M_sum) - digamma(R) + digamma(S_sum))) +
            mu^(2 - p) * M_sum * (
              mu^(2 - p) * (-log(R) + log(M_sum) + digamma(R) - digamma(S_sum)) +
                mu^(2 - p) - M_sum - R * M_sum * (-trigamma(R) + trigamma(S_sum))
            )
        ) -
          mu^(2 - p) * M_sum * (mu - y + M_sum * (log(R) - log(M_sum) - digamma(R) + digamma(S_sum)))
      ) / (alpha * (alpha * M_sum)^2))
    }
    
    # Hessian with respect to ln(alpha)
    if (form=="nb2"){
      lnAlpha_hessian <- -(alpha-alpha*(alpha*mu+1)^2*digamma(y+1/alpha)+(alpha*mu+1)^2*trigamma(y+1/alpha))/((alpha*mu+1)^2)
    }
    else{
      lnAlpha_hessian <- -1*(
        -alpha^2 * mu^(3 - p) * (-alpha * mu + alpha * y + M_sum * (-log(R) + log(M_sum) + digamma(R) - digamma(S_sum))) -
          2 * alpha * mu^(2 - p) * M_sum * (-alpha * mu + alpha * y + M_sum * (-log(R) + log(M_sum) + digamma(R) - digamma(S_sum))) +
          alpha * mu^(2 - p) * M_sum * (-alpha * mu + alpha * y - M_sum * (log(R) - log(M_sum) - digamma(R) + digamma(S_sum))) -
          mu^(2 - p) * M_sum * (
            alpha^2 * (-mu * (-log(R) + log(M_sum) + digamma(R) - digamma(S_sum)) + mu - y) +
              alpha * mu^(2 - p) - alpha * M_sum +
              mu^(2 - p) * M_sum * trigamma(R) - mu^(2 - p) * M_sum * trigamma(S_sum)
          )
      ) / (alpha^2 * M_sum^2)
    }
    
    
    # Hessian with respect to beta_alpha
    if (!is.null(alpha_X)){
      
      if (alpha_X_cols>1){
        scaled_alpha_X <- alpha_X
        
        for (i in 1:alpha_X_cols){
          scaled_alpha_X[,i] <- alpha_X[,i] * lnAlpha_hessian
        }
        
        hessian_beta_alpha <- t(alpha_X) %*% scaled_alpha_X
      }
      else{
        hessian_beta_alpha <- sum(alpha_X^2 * lnAlpha_hessian)
      }
    }
    else{
      hessian_beta_alpha <- sum(lnAlpha_hessian)
    }
    
    if (form=="nb2"){
      beta_cons <- -mu*(alpha*y+1)/((alpha*mu+1)^2)
    }
    else{
      beta_cons <- ((p-2)*M_sum*(y*(p-1)-mu+(p-2)*M_sum*(log(M_sum)-log(R)-digamma(S_sum)+digamma(R))-(p-2)*M_sum+mu^(2-p))*mu^(2-p))/M_sum^2
    }
    
    x_scaled <- X
    
    for (i in 1:ncol(X)){
      x_scaled[,i] <- X[,i] * beta_cons
    }
    
    # Hessian with respect to beta
    hessian_beta <- t(X)%*%x_scaled
    
    # Combine all Hessian values into a single matrix
    if (form=="nbp"){
      n <- nrow(hessian_beta) + alpha_X_cols + 1
    }
    else{
      n <- nrow(hessian_beta) + alpha_X_cols
    }
    
    # Create an extended matrix initialized with zeros
    H <- matrix(0, nrow=n, ncol=n)
    
    H[1:nrow(hessian_beta), 1:ncol(hessian_beta)] <- hessian_beta
    
    if (alpha_X_cols>1){
      H[(nrow(hessian_beta)+1):(nrow(hessian_beta)+alpha_X_cols), (nrow(hessian_beta)+1):(nrow(hessian_beta)+alpha_X_cols)] <- hessian_beta_alpha
    }
    else{
      H[(nrow(hessian_beta)+1), (nrow(hessian_beta)+1)] <- hessian_beta_alpha
    }
    
    if (form == 'nbp'){
      H[n,n] <- lnP_hessian
    }
    return(H)
  }
  
  
  
  # Run the maximum likelihood estimation
  fit <- maxLik::maxLik(reg.run,
                        start = unname(full_start),
                        grad = if (method == 'BHHH') gradFun else function(...) colSums(gradFun(...)),
                        hess = hessianFun,
                        y = y,
                        X = X,
                        alpha_X = alpha_X,
                        method = method,
                        iterlim = max.iters)
  
  beta_est <- fit$estimate
  alpha_coefs <- beta_est[(modparams + 1):(modparams + alpha_X_cols)]
  
  if (form=="nbp") p <- beta_est[length(beta_est)] else p <- NULL
  
  beta_pred <- beta_est[1:modparams]
  
  names(fit$estimate) <- x_names
  fit$beta_pred <- beta_pred # save coefficients for predictions
  fit$formula <- formula
  fit$form <- form
  fit$ln_alpha <- alpha_coefs # natural log of alpha or the parameters for it
  fit$p <- p
  fit$modelType <- "nbg"
  fit$predictions <- exp(X %*% beta_pred)
  fit$observed <- y
  fit$residuals <- y - fit$predictions
  fit$LL <- fit$maximum # The log-likelihood of the model

  return(fit)
}
