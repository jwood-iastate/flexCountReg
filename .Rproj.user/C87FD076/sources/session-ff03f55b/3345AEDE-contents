#' Poisson-Weibull Regression with Optional Random Parameters
#'
#' Estimates a Poisson-Weibull regression model with optional random parameters. 
#' This function allows for the specification of parameters that can vary 
#' randomly across observations, modeled through the inclusion of Halton draws.
#'
#' @name pwiebreg
#' @param formula A symbolic description of the model to be fitted, specifying the outcome
#'        and the independent variables with fixed effects.
#' @param rpar_formula An optional symbolic description of the model for random parameters,
#'        excluding the outcome variable. Use 0 + vars or -1 + vars to exclude the intercept.
#' @param alpha_formula A symbolic description of the model for the alpha parameter,
#'        specifying the distribution parameter as a function of predictor variables.
#' @param beta_formula A symbolic description of the model for the beta parameter,
#'        specifying the distribution parameter as a function of predictor variables.
#' @param data A dataframe containing all variables included in 'formula', 'rpar_formula', 'alpha_formula', and 'beta_formula'.
#' @param rpardists An optional named vector specifying the distributions of the random parameters.
#'        Possible values include normal ("n"), lognormal ("ln"), and others as needed.
#'        Defaults to normal if not specified.
#' @param ndraws The number of Halton draws for estimating random parameters.
#' @param scrambled Boolean to determine if Halton sequences should be scrambled.
#' @param correlated Boolean indicating if random parameters are correlated.
#'        If TRUE, only normal distributions are used for random parameters.
#' @param method Optimization method to be used for maximum likelihood estimation.
#'        See `maxLik` documentation for options.
#' @param max.iters Maximum number of iterations for the optimization method.
#' @param start.vals Optional vector of starting values for the optimization.
#' @param print.level Integer specifying the verbosity of output during optimization.
#' @param bootstraps Optional integer specifying the number of bootstrap samples to be used
#'        for estimating standard errors.
#'        
#' @importFrom stats model.frame model.matrix
#' @importFrom maxLik maxLik
#' @importFrom randtoolbox halton
#' @include poisWeib.R
#' 
#' @examples
#' \donttest{
#' data("washington_roads")
#' pw_rp <- pwiebreg(Total_crashes ~ lnlength + lnaadt,
#'                                  rpar_formula = ~ speed50,
#'                                  alpha_formula = ~ lnlength,
#'                                  beta_formula = ~ lnaadt,
#'                                  data = washington_roads,
#'                                  ndraws = 10,
#'                                  correlated = FALSE)
#' print(summary(pw_rp))
#' }
#' @export
pwiebreg <- function(formula, rpar_formula = NULL, alpha_formula, beta_formula, data,
                                    rpardists = NULL, ndraws = 1500, scrambled = FALSE,
                                    correlated = FALSE, method = 'BHHH', max.iters = 1000,
                                    start.vals = NULL, print.level = 0, bootstraps = NULL) {
  
  # Generate Halton sequences for the random parameters
  halton_draws <- function(ndraws, rpar, scrambled) {
    num_params <- length(rpar)
    halton_seq <- randtoolbox::halton(ndraws, num_params, mixed = scrambled)
    return(halton_seq)
  }
  
  # Prepare model matrices for fixed effects, random effects (if provided), alpha parameter, and beta parameter
  mod1_frame <- stats::model.frame(formula, data)
  X_Fixed <- model.matrix(formula, data)
  X_alpha <- model.matrix(alpha_formula, data)
  X_beta <- model.matrix(beta_formula, data)
  y <- model.response(mod1_frame)
  
  if (!is.null(rpar_formula)) {
    X_rand <- model.matrix(rpar_formula, data)
  } else {
    X_rand <- NULL
  }
  
  # Define the main function for computing log-likelihood
  p_poisweibull_rp <- function(p, y, X_Fixed, X_rand, X_alpha, X_beta, ndraws, rpar, correlated, est_method) {
    N_fixed = ncol(X_Fixed)
    N_alpha = ncol(X_alpha)
    N_beta = ncol(X_beta)
    coefs <- as.array(p)
    fixed_coefs <- head(coefs, N_fixed)
    alpha_coefs <- coefs[(N_fixed + 1):(N_fixed + N_alpha)]
    beta_coefs <- tail(coefs, N_beta)
    
    mu_fixed <- exp(X_Fixed %*% fixed_coefs)
    alpha <- exp(X_alpha %*% alpha_coefs)
    beta <- exp(X_beta %*% beta_coefs)
    
    if (!is.null(X_rand)) {
      N_rand = ncol(X_rand)
      random_coefs_means <- tail(coefs, N_rand)
      
      draws <- if (correlated) {
        # Correlated random effects implementation
      } else {
        rand_sdevs <- tail(coefs, N_rand)
        hdraws <- halton_draws(ndraws, rpar, scrambled)
        apply(hdraws, 1, function(x) stats::qnorm(x, mean = random_coefs_means, sd = rand_sdevs))
      }
      
      xb_rand_mat <- sapply(draws, function(x) X_rand * x)
      rpar_mat <- exp(xb_rand_mat)
      pred_mat <- apply(rpar_mat, 2, function(x) x * mu_fixed)
    } else {
      pred_mat <- mu_fixed
    }
    
    # Call the provided Poisson-Weibull density function
    probs <- apply(pred_mat, 2, function(lambda) dpoisweibull(x = y, alpha = alpha, beta = beta, log = FALSE))
    
    ll <- sum(log(rowMeans(probs)))
    
    if (est_method == 'bhhh' || method == 'BHHH') {
      return(log(probs))
    } else {
      return(ll)
    }
  }
  
  # Initialize starting values if not provided
  if (is.null(rpar_formula)) {
    start <- if (is.null(start.vals)) {
      coefs <- rep(0, ncol(X_Fixed) + ncol(X_alpha) + ncol(X_beta))
    } else {
      start.vals
    }
  } else {
    start <- if (is.null(start.vals)) {
      coefs <- rep(0, ncol(X_Fixed) + ncol(X_rand) + ncol(X_alpha) + ncol(X_beta))
    } else {
      start.vals
    }
  }
  
  # Run the maximum likelihood estimation
  fit <- maxLik::maxLik(p_poisweibull_rp, start = start,
                        y = y, X_Fixed = X_Fixed, X_rand = X_rand, X_alpha = X_alpha, X_beta = X_beta,
                        ndraws = ndraws, rpar = if (!is.null(X_rand)) colnames(X_rand) else NULL,
                        correlated = correlated, est_method = method,
                        method = method, control = list(iterlim = max.iters, printLevel = print.level))
  
  # Optionally, compute bootstrapped standard errors
  if (!is.null(bootstraps) & is.numeric(bootstraps)) {
    boot_err <- matrix(0, ncol = bootstraps, nrow = length(start))
    for (i in 1:bootstraps) {
      # Generate random sample of row indices with replacement - number of samples = number of observations
      sampled_indices <- sample(nrow(data), nrow(data), replace = TRUE)
      
      # Subset matrices and vector using sampled indices
      sampled_X_Fixed <- X_Fixed[sampled_indices, ]
      sampled_X_rand <- if (!is.null(X_rand)) X_rand[sampled_indices, ] else NULL
      sampled_X_alpha <- X_alpha[sampled_indices, ]
      sampled_X_beta <- X_beta[sampled_indices, ]
      sampled_y <- y[sampled_indices]
      
      model.boot <- maxLik::maxLik(p_poisweibull_rp,
                                   start = start,
                                   y = sampled_y,
                                   X_Fixed = sampled_X_Fixed,
                                   X_rand = sampled_X_rand,
                                   X_alpha = sampled_X_alpha,
                                   X_beta = sampled_X_beta,
                                   ndraws = ndraws,
                                   rpar = if (!is.null(X_rand)) colnames(X_rand) else NULL,
                                   correlated = correlated,
                                   est_method = method,
                                   method = method,
                                   control = list(iterlim = max.iters, 
                                                  printLevel = print.level))
      boot_err[, i] <- fit$estimate - model.boot$estimate
    }
    
    stderr <- apply(boot_err, 1, sd)
    fit$bootstrapped_se <- stderr
  }
  
  fit$coefficients = fit$estimate
  fit$vcov = if (correlated) chol2inv(fit$hessian) else diag(ncol(X_rand))
  fit$se = if (!is.null(bootstraps) & is.numeric(bootstraps)) fit$bootstrapped_se else sqrt(diag(fit$hessian))
  fit$logLik = fit$minimum
  fit$converged = fit$convergence
  fit$model = "rpoisweibull_regression"
  fit$method = method
  fit$data = data
  fit$formula = formula
  fit$rpar_formula = rpar_formula
  fit$alpha_formula = alpha_formula
  fit$beta_formula = beta_formula
  fit$rpardists = rpardists
  fit$ndraws = ndraws
  fit$scrambled = scrambled
  fit$correlated = correlated
  fit$bootstraps = if (!is.null(bootstraps)) bootstraps else NULL
  
  return(fit)
}
