#' Poisson-Generalized-Exponential Regression
#' 
#' @name poisGE
#' @param formula an R formula.
#' @param data a dataframe that has all of the variables in the \code{formula} and \code{rpar_formula}. This can be the data used for estimating the model or another dataframe,
#' @param ln.scale.formula an optional formula for using independent variables to estimate the natural log of the scale parameter.
#' @param ndraws the number of Halton draws to use for the integration over the lognormal distribution.
#' @param method a method to use for optimization in the maximum likelihood estimation. For options, see \code{\link[maxLik]{maxLik}},
#' @param max.iters the maximum number of iterations to allow the optimization method to perform.
#' @param print.level determines the level of verbosity for printing details of the optimization as it is computed. A value of 0 does not print out any information, a value of 1 prints minimal information, and a value of 2 prints the most information.
#'
#' @details
#' This implements maximum simulated likelihood (MSL) to estimate a Poisson-Generalized Exponential regression model. The regression model has the flexibility to model the scale parameter as a function of independent variables, similar to the generalized negative binomial.
#'
#' Details of the distribution can be found with the function \code{\link{dpge}}
#' The t-statistics and p-values for the coefficients related to ln(sigma) are,
#' by default, testing if the coefficients are different from a value of 0. This
#' has little practical meaning given that they are coefficients for ln(sigma).
#' They are not testing if the coefficients have statistical significance in
#' terms of improvement over a Poisson model. The Likelihood-Ratio test results
#' provided in the output provide a test comparing if the Poisson-Lognormal
#' model provides a statistically significant improvement in model fit over the
#' Poisson model.
#'
#' @import nlme  maxLik  MASS  stats modelr
#' @include ppoisGE.R
#' @export
#' @examples
#' \donttest{
#'
#' ## Generalized Poisson-Lognormal
#' data("washington_roads")
#' washington_roads$AADTover10k <- ifelse(washington_roads$AADT>10000,1,0)
#'
#' poisge.mod <- poisGE(Total_crashes ~ lnaadt + lnlength + speed50 +
#'                         ShouldWidth04 + AADTover10k,
#'                         ln.scale.formula = ~ lnaadt,
#'                         data=washington_roads[1:500,], 
#'                         ndraws = 100,
#'                         max.iters = 500, 
#'                         method = 'nm')
#' summary(poisge.mod)
#' }
poisGE <- function(formula, data, ln.scale.formula = NULL, ndraws = 1500, 
                   method = 'BHHH', max.iters = 200, print.level = 0) {
  
  mod_df <- stats::model.frame(formula, data)
  X <- as.matrix(modelr::model_matrix(data, formula))
  y <- as.numeric(stats::model.response(mod_df))
  x_names <- colnames(X)
  n.coefs <- ncol(X)
  n.obs <- length(y)
  
  # Use the Poisson as starting values
  p_model <- MASS::glm.nb(formula, data = data)
  start <- unlist(p_model$coefficients)
  start <- append(start, 0) # Append ln(shape)
  
  if (is.null(ln.scale.formula)) {
    full_start <- append(start, 0) # Append ln(scale)
  } else {
    scale_X <- stats::model.matrix(ln.scale.formula, data)
    S <- as.matrix(scale_X)
    scale_names <- colnames(S)
    s_coefs <- rep(0, length(scale_names))
    full_start <- c(start, s_coefs)
  }
  
  modparams <- length(full_start) # total number of model parameters, including ln(shape) and ln(scale) or scale coefficients
  
  # Log-likelihood function
  logLikFun <- function(beta, y, X, S = NULL, ndraws) {
    coefs <- beta[1:n.coefs]
    shape <- exp(beta[(n.coefs + 1)])
    if (is.null(S)) {
      scale <- exp(beta[modparams])
    } else {
      scale_pars <- beta[(n.coefs + 2):modparams]
      scale <- exp(S %*% scale_pars)
    }
    
    predicted <- exp(X %*% coefs)
    probs <- dpge(x = y, mean = predicted, shape = shape, scale = scale, ndraws = ndraws)
    ll <- sum(log(probs))
    
    return(ll)
  }
  
  # Gradient (Jacobian) function for BHHH
  gradFun <- function(beta, y, X, S = NULL, ndraws) {
    grad <- matrix(0, nrow = n.obs, ncol = length(beta))
    
    coefs <- beta[1:n.coefs]
    shape <- exp(beta[(n.coefs + 1)])
    if (is.null(S)) {
      scale <- exp(beta[modparams])
    } else {
      scale_pars <- beta[(n.coefs + 2):modparams]
      scale <- exp(S %*% scale_pars)
    }
    
    predicted <- exp(X %*% coefs)
    lambda <- predicted * scale / (digamma(shape + 1) - digamma(1))
    
    for (i in 1:n.obs) {
      x_i <- X[i, ]
      mu_i <- lambda[i]
      grad_beta <- (y[i] - mu_i) * x_i
      grad_shape <- (y[i] - mu_i) * (-digamma(shape + 1) + digamma(1)) / (digamma(shape + 1) - digamma(1))
      
      if(i==1){
      }
      if (is.null(S)) {
        grad_scale <- (y[i] - mu_i) / scale
        if(i==1){
        }
        grad[i, ] <- c(grad_beta, grad_shape, grad_scale)
      } else {
        grad_scale <- (y[i] - mu_i) * S[i, ] / scale[i]
        if(i==1){
        }
        grad[i, ] <- c(grad_beta, grad_shape, grad_scale)
      }
    }
    
    return(grad)
  }
  
  # Hessian function
  hessFun <- function(beta, y, X, S = NULL, ndraws) {
    hess <- matrix(0, modparams, modparams)
    
    coefs <- beta[1:n.coefs]
    shape <- exp(beta[(n.coefs + 1)])
    if (is.null(S)) {
      scale <- exp(beta[modparams])
    } else {
      scale_pars <- beta[(n.coefs + 2):modparams]
      scale <- exp(S %*% scale_pars)
    }
    
    predicted <- exp(X %*% coefs)
    lambda <- predicted * scale / (digamma(shape + 1) - digamma(1))
    
    for (i in seq_along(y)) {
      x_i <- X[i, ]
      mu_i <- lambda[i]
      
      hess_beta_beta <- -mu_i * (x_i %*% t(x_i))
      hess_shape_shape <- -mu_i * (trigamma(shape + 1) - trigamma(1)) / ((digamma(shape + 1) - digamma(1))^2)
      hess_scale_scale <- -mu_i / (scale[i] ^ 2)
      
      hess_beta_shape <- -mu_i * x_i * (trigamma(shape + 1) - trigamma(1)) / ((digamma(shape + 1) - digamma(1))^2)
      hess_beta_scale <- -mu_i * (x_i / scale[i])
      hess_shape_scale <- -mu_i * (trigamma(shape + 1) - trigamma(1)) / ((digamma(shape + 1) - digamma(1))^2 * scale[i])
      
      hess[1:length(coefs), 1:length(coefs)] <- hess[1:length(coefs), 1:length(coefs)] + hess_beta_beta
      hess[length(coefs) + 1, length(coefs) + 1] <- hess[length(coefs) + 1, length(coefs) + 1] + hess_shape_shape
      if (!is.null(S)) {
        for (j in 1:ncol(S)) {
          hess[length(coefs) + 1, length(coefs) + 1 + j] <- hess[length(coefs) + 1, length(coefs) + 1 + j] + hess_shape_scale[j]
          hess[length(coefs) + 1 + j, length(coefs) + 1] <- hess[length(coefs) + 1 + j, length(coefs) + 1] + hess_shape_scale[j]
          for (k in 1:ncol(S)) {
            hess[length(coefs) + 1 + j, length(coefs) + 1 + k] <- hess[length(coefs) + 1 + j, length(coefs) + 1 + k] + hess_scale_scale[j, k]
            hess[length(coefs) + 1 + k, length(coefs) + 1 + j] <- hess[length(coefs) + 1 + k, length(coefs) + 1 + j] + hess_scale_scale[k, j]
          }
        }
      } else {
        hess[length(coefs) + 2, length(coefs) + 2] <- hess[length(coefs) + 2, length(coefs) + 2] + hess_scale_scale
      }
      
      hess[1:length(coefs), length(coefs) + 1] <- hess[1:length(coefs), length(coefs) + 1] + hess_beta_shape
      if (!is.null(S)) {
        for (j in 1:ncol(S)) {
          hess[1:length(coefs), length(coefs) + 1 + j] <- hess[1:length(coefs), length(coefs) + 1 + j] + hess_beta_scale[j]
          hess[length(coefs) + 1 + j, 1:length(coefs)] <- hess[length(coefs) + 1 + j, 1:length(coefs)] + hess_beta_scale[j]
        }
      } else {
        hess[1:length(coefs), length(coefs) + 2] <- hess[1:length(coefs), length(coefs) + 2] + hess_beta_scale
        hess[length(coefs) + 2, 1:length(coefs)] <- hess[length(coefs) + 2, 1:length(coefs)] + hess_beta_scale
      }
    }
    
    return(hess)
  }
  
  fit <- maxLik::maxLik(
    logLik = logLikFun,
    grad = if (method == 'BHHH') gradFun else function(...) colSums(gradFun(...)),
    hess = hessFun,
    start = full_start,
    y = y,
    X = X,
    S = if (is.null(ln.scale.formula)) NULL else S,
    ndraws = ndraws,
    method = method,
    control = list(iterlim = max.iters, printLevel = print.level)
  )
  
  beta_est <- fit$estimate
  betas <- beta_est[1:n.coefs]
  beta_pred <- as.vector(unlist(betas))
  
  pred <- exp(X %*% beta_pred)
  
  beta_dist_params <- as.vector(beta_est[(n.coefs+1):length(beta_est)])
  shape <- exp(beta_dist_params[1])
  fit$shape <- shape
  if (is.null(ln.scale.formula)) {
    scale <- exp(beta_dist_params[2])
    fit$scale <- scale
  } else {
    scale_coefs <- beta_dist_params[2:length(beta_dist_params)]
    fit$scale_coefs <- scale_coefs
    scales <- exp(S %*% scale_coefs)
    fit$scales <- scales
  }
  
  x_names <- append(x_names, 'ln(shape)')
  if (is.null(ln.scale.formula)) {
    x_names <- append(x_names, 'ln(scale)')
  } else {
    x_names <- append(x_names, paste0('ln(scale):', scale_names))
  }
  
  names(fit$estimate) <- x_names
  fit$beta_pred <- beta_pred # save coefficients for predictions
  fit$formula <- formula
  fit$ln.scale.formula <- ln.scale.formula
  fit$modelType <- "Poisson-Generalized-Exponential"
  fit$predictions <- pred
  fit$observed <- y
  fit$residuals <- y - fit$predictions
  fit$LL <- fit$maximum # The log-likelihood of the model
  
  return(fit)
}

