#' Random Parameters Poisson Model
#'
#' Estimates a Poisson regression model with the possibility of random parameters. This function
#' allows for the specification of parameters that can vary randomly across observations,
#' modeled through the inclusion of Halton draws.
#'
#' @name rppoisson
#' @param formula A symbolic description of the model to be fitted, specifying the outcome
#'        and the independent variables with fixed effects.
#' @param rpar_formula A symbolic description of the model for random parameters,
#'        excluding the outcome variable. Use 0 + vars or -1 + vars to exclude the intercept.
#' @param data A dataframe containing all variables included in 'formula' and 'rpar_formula'.
#' @param rpardists An optional named vector specifying the distributions of the random parameters.
#'        Possible values include normal ("n"), lognormal ("ln"), and others as needed.
#'        Defaults to normal if not specified.
#' @param ndraws The number of Halton draws for estimating random parameters.
#' @param scrambled Boolean to determine if Halton sequences should be scrambled.
#' @param correlated Boolean indicating if random parameters are correlated.
#'        If TRUE, only normal distributions are used for random parameters.
#' @param method Optimization method to be used for maximum likelihood estimation.
#'        See `maxLik` documentation for options.
#' @param max.iters Maximum number of iterations for the optimization method.
#' @param start.vals Optional vector of starting values for the optimization.
#' @param print.level Integer specifying the verbosity of output during optimization.
#' @param bootstraps Optional integer specifying the number of bootstrap samples to be used
#'        for estimating standard errors.
#' @return An object of class 'rppoisson' containing the model's estimated coefficients, the variance-covariance matrix of the random parameters (if correlated),
#'         standard errors, and other diagnostic measures.
#' @importFrom stats model.frame model.matrix dpois
#' @importFrom maxLik maxLik
#' @importFrom randtoolbox halton
#' @examples
#' \dontrun{
#' data("washington_roads")
#' poisson_rp <- rppoisson(Total_crashes ~ lnlength + lnaadt,
#'                         rpar_formula = ~ speed50,
#'                         data = washington_roads,
#'                         ndraws = 10,
#'                         correlated = FALSE)
#' print(summary(poisson_rp))
#' }
#' @export
rppoisson <- function(formula, rpar_formula, data,
                      rpardists = NULL, ndraws = 1500, scrambled = FALSE,
                      correlated = FALSE, method = 'BHHH', max.iters = 1000,
                      start.vals = NULL, print.level = 0, bootstraps = NULL) {
  
  # Generate Halton sequences for the random parameters
  halton_draws <- function(ndraws, rpar, scrambled) {
    num_params <- length(rpar)
    halton_seq <- randtoolbox::halton(ndraws, num_params, mixed = scrambled)
    return(halton_seq)
  }
  
  # Prepare model matrices for fixed and random effects
  mod1_frame <- stats::model.frame(formula, data)
  X_Fixed <- model.matrix(mod1_frame, formula)
  X_rand <- model.matrix(mod1_frame, rpar_formula)
  y <- model.response(mod1_frame)
  
  # Define the main function for computing log-likelihood
  p_poisson_rp <- function(p, y, X_Fixed, X_rand, ndraws, rpar, correlated, est_method) {
    N_fixed = ncol(X_Fixed)
    N_rand = ncol(X_rand)
    coefs <- as.array(p)
    fixed_coefs <- head(coefs, N_fixed)
    h <- head(coefs, (N_fixed + N_rand))
    random_coefs_means <- tail(h, N_rand)
    
    mu_fixed <- exp(X_Fixed %*% fixed_coefs)
    
    draws <- if (correlated) {
      # Correlated random effects implementation
    } else {
      rand_sdevs <- tail(coefs, N_rand)
      hdraws <- halton_draws(ndraws, rpar, scrambled)
      apply(hdraws, 1, function(x) stats::qnorm(x, mean = random_coefs_means, sd = rand_sdevs))
    }
    
    xb_rand_mat <- sapply(draws, function(x) X_rand * x)
    rpar_mat <- exp(xb_rand_mat)
    pred_mat <- apply(rpar_mat, 2, function(x) x * mu_fixed)
    probs <- apply(pred_mat, 2, function(lambda) stats::dpois(y, lambda = lambda))
    
    ll <- sum(log(rowMeans(probs)))
    
    if (est_method == 'bhhh' || method == 'BHHH') {
      return(log(probs))
    } else {
      return(ll)
    }
  }
  
  # Initialize starting values if not provided
  start <- if (is.null(start.vals)) {
    coefs <- rep(0, ncol(X_Fixed) + ncol(X_rand))
  } else {
    start.vals
  }
  
  # Run the maximum likelihood estimation
  fit <- maxLik::maxLik(p_poisson_rp, start = start,
                        y = y, X_Fixed = X_Fixed, X_rand = X_rand, 
                        ndraws = ndraws, rpar = colnames(X_rand),
                        correlated = correlated, est_method = method,
                        method = method, control = list(iterlim = max.iters, printLevel = print.level))
  
  # Optionally, compute bootstrapped standard errors
  if (!is.null(bootstraps) & is.numeric(bootstraps)) {
    # Generate R bootstrap samples
    for (i in 1:bootstraps) {
      # Generate random sample of row indices with replacement - number of samples = number of observations
      sampled_indices <- sample(n, n, replace = TRUE)
      
      # Subset matrices and vector using sampled indices
      sampled_X_Fixed <- X_Fixed[sampled_indices, ]
      sampled_X_rand <- X_rand[sampled_indices, ]
      sampled_y <- y[sampled_indices]
      
      model.boot <- maxLik::maxLik(p_poisson_rp,
                                   start = orig.coef,
                                   y = sampled_y,
                                   X_Fixed = sampled_X_Fixed,
                                   X_rand = sampled_X_rand,
                                   ndraws = ndraws,
                                   rpar = rpar,
                                   correlated = correlated,
                                   est_method = method,
                                   method = method,
                                   control = list(iterlim = max.iters, 
                                                  printLevel = print.level))
      print(paste("bootstrap iteration", i, "Coefficients:", unname(model.boot$estimate)))
      boot_err <- cbind(boot_err, orig.coef - unname(model.boot$estimate))
    }
    
    stderr <- apply(boot_err, 1, sd)
    
    fit$bootstrapped_se <- stderr
    
  }
  
  fit$coefficients = fit$estimate
  fit$vcov = if (correlated) chol2inv(fit$hessian) else diag(ncol(X_rand))
  fit$se = if (!is.null(bootstraps) & is.numeric(bootstraps)) fit$bootstrapped_se else sqrt(diag(fit$hessian))
  fit$logLik = fit$minimum
  fit$converged = fit$convergence
  fit$model = "rppoisson"
  fit$method = method
  fit$data = data
  fit$formula = formula
  fit$rpar_formula = rpar_formula
  fit$rpardists = rpardists
  fit$ndraws = ndraws
  fit$scrambled = scrambled
  fit$correlated = correlated
  fit$bootstraps = if (!is.null(bootstraps)) bootstraps else NULL

  return(fit)
}
